#include <stdio.h>
#include "reverse_elf.h"
#include "elf_object.h"
#include "types.h"
/*
 
  Extracted from elf.h
#define EI_NIDENT (16)

typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	// Magic number and other info 
  Elf32_Half	e_type;			// Object file type 
  Elf32_Half	e_machine;		// Architecture 
  Elf32_Word	e_version;		// Object file version 
  Elf32_Addr	e_entry;		// Entry point virtual address 
  Elf32_Off	e_phoff;		// Program header table file offset 
  Elf32_Off	e_shoff;		// Section header table file offset 
  Elf32_Word	e_flags;		// Processor-specific flags 
  Elf32_Half	e_ehsize;		// ELF header size in bytes 
  Elf32_Half	e_phentsize;		// Program header table entry size 
  Elf32_Half	e_phnum;		// Program header table entry count 
  Elf32_Half	e_shentsize;		// Section header table entry size 
  Elf32_Half	e_shnum;		// Section header table entry count 
  Elf32_Half	e_shstrndx;		// Section header string table index 
} Elf32_Ehdr;

// Program segment header.  

typedef struct
{
  Elf32_Word	p_type;			// Segment type 
  Elf32_Off	p_offset;		// Segment file offset 
  Elf32_Addr	p_vaddr;		// Segment virtual address 
  Elf32_Addr	p_paddr;		// Segment physical address 
  Elf32_Word	p_filesz;		// Segment size in file 
  Elf32_Word	p_memsz;		// Segment size in memory 
  Elf32_Word	p_flags;		// Segment flags 
  Elf32_Word	p_align;		// Segment alignment 
} Elf32_Phdr;


*/

#define TOP_TEMPLATE "#include <elf.h>\n\n"
#define PRINT_C(format...) fprintf(fd, format)
#define PRINT_FILEADDR PRINT_C("/* %06x */", file_addr);
#define PRINT_CHAR(str, size, desc) do { PRINT_FILEADDR \
 PRINT_C("\t\"");                                         \
 for (_i_ = 0; _i_ < size; ++_i_) { \
   PRINT_C("\\x%x", str[_i_]); } \
 PRINT_C("\",\n"); file_addr += size; } while(0)

#define PRINT_WORD(value, desc) do { PRINT_FILEADDR PRINT_C("\t%d,\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_WORD_END(value, desc) do { PRINT_FILEADDR PRINT_C("\t%d\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_HALF(value, desc) PRINT_WORD(value, desc)
#define PRINT_ADDR(value, desc) do { PRINT_FILEADDR PRINT_C("\t0x%x,\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_ADDR_END(value, desc) do { PRINT_FILEADDR PRINT_C("\t0x%x\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_OFF(value, desc) PRINT_ADDR(value, desc)


_u8 reverse_elf2c(elf_object* elf, FILE* fd) {
  ElfW(Ehdr)* header;
  ElfW(Phdr)* pheader;
  unsigned int file_addr = 0, _i_, i;

  header = (ElfW(Ehdr)*) elf->mem;
  pheader = (ElfW(Phdr)*) (elf->mem + header->e_phoff);

  PRINT_C(TOP_TEMPLATE);

  PRINT_C("Elf32_Ehdr elf_header = {\n");
  PRINT_CHAR(header->e_ident, EI_NIDENT, "Magic numbers");
  PRINT_HALF(header->e_type, GET_DESC_TYPE(header));
  PRINT_HALF(header->e_machine, GET_DESC_MACHINE(header));
  PRINT_WORD(header->e_version, "CURRENT VERSION");
  PRINT_ADDR(header->e_entry, "Entry point");
  PRINT_OFF(header->e_phoff, "Program Header Table file offset");
  PRINT_OFF(header->e_shoff, "Section Header Table file offset");
  PRINT_WORD(header->e_flags, "Processor Spacefic-Flags");
  PRINT_HALF(header->e_ehsize, "ELF Header size in bytes");
  PRINT_HALF(header->e_phentsize, "Program Header Table entry size");
  PRINT_HALF(header->e_phnum, "Program Header Table entry count");
  PRINT_HALF(header->e_shentsize, "Section Header Table entry size");
  PRINT_HALF(header->e_shnum, "Section Header Table entry size");
  PRINT_WORD_END(header->e_shstrndx, "Section Header string table index");
  PRINT_C("};\n\n");

  PRINT_C("Elf32_Phdr pht = {\n");
  for (i = 0; i < header->e_phnum; i++) {
    ElfW(Phdr)* p = (ElfW(Phdr)*) (pheader + i);
    PRINT_OFF(p->p_type, GET_DESC_SEGTYPE(p));
    PRINT_OFF(p->p_offset, "Offset");
  
  }
  return 0; 
}
