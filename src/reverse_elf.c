#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <sys/mman.h>
#include <libgen.h>
#include "reverse_elf.h"
#include "malelf_object.h"
#include "types.h"
#include "util.h"
/*
 
  Extracted from elf.h
#define EI_NIDENT (16)

typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	// Magic number and other info 
  Elf32_Half	e_type;			// Object file type 
  Elf32_Half	e_machine;		// Architecture 
  Elf32_Word	e_version;		// Object file version 
  Elf32_Addr	e_entry;		// Entry point virtual address 
  Elf32_Off	e_phoff;		// Program header table file offset 
  Elf32_Off	e_shoff;		// Section header table file offset 
  Elf32_Word	e_flags;		// Processor-specific flags 
  Elf32_Half	e_ehsize;		// ELF header size in bytes 
  Elf32_Half	e_phentsize;		// Program header table entry size 
  Elf32_Half	e_phnum;		// Program header table entry count 
  Elf32_Half	e_shentsize;		// Section header table entry size 
  Elf32_Half	e_shnum;		// Section header table entry count 
  Elf32_Half	e_shstrndx;		// Section header string table index 
} Elf32_Ehdr;

// Program segment header.  

typedef struct
{
  Elf32_Word	p_type;			// Segment type 
  Elf32_Off	p_offset;		// Segment file offset 
  Elf32_Addr	p_vaddr;		// Segment virtual address 
  Elf32_Addr	p_paddr;		// Segment physical address 
  Elf32_Word	p_filesz;		// Segment size in file 
  Elf32_Word	p_memsz;		// Segment size in memory 
  Elf32_Word	p_flags;		// Segment flags 
  Elf32_Word	p_align;		// Segment alignment 
} Elf32_Phdr;

typedef struct
{
  Elf32_Word	sh_name;		// Section name (string tbl index) 
  Elf32_Word	sh_type;		// Section type 
  Elf32_Word	sh_flags;		// Section flags 
  Elf32_Addr	sh_addr;		// Section virtual addr at execution 
  Elf32_Off	sh_offset;		// Section file offset 
  Elf32_Word	sh_size;		// Section size in bytes 
  Elf32_Word	sh_link;		// Link to another section 
  Elf32_Word	sh_info;		// Additional section information 
  Elf32_Word	sh_addralign;		// Section alignment 
  Elf32_Word	sh_entsize;		// Entry size if section holds table 
} Elf32_Shdr;

*/

#define TOP_TEMPLATE_COMMENT "/**\n \
* This file was generated by Malelficus \n \
*/\n"
#define TOP_TEMPLATE TOP_TEMPLATE_COMMENT "#include <stdio.h>\n \
#include <elf.h>\n \
#include <sys/types.h> \n\
#include <sys/stat.h>\n#include <unistd.h>\n\
#include <fcntl.h>\n\n"
#define SELF_GENERATE_SRC "int main() { \n" \
"    int fd; \n" \
"    fd = open(\"%s\", O_RDWR|O_CREAT); \n" \
"    if (fd == -1) { \n" \
"        perror(\"Error opening file ...\\n\"); \n" \
"        return 1; \n" \
"    } \n" \
"    if (write(fd, &elf_header, sizeof(elf_header)) != sizeof (elf_header)) { \n" \
"        perror(\"Error writing header to file\\n\"); \n" \
"        return 1; \n" \
"    } \n" \
"    if (write(fd, pht, sizeof(pht)) != sizeof (pht)) { \n" \
"        perror(\"Error writing pht to file\\n\"); \n" \
"        return 1; \n" \
"    } \n" \
"    if (write(fd, segments, sizeof(segments)) != sizeof(segments)) { \n" \
"        perror(\"Error writing segments to file...\\n\"); \n" \
"        return 1; \n" \
"    } \n" \
"    if (write(fd, &sht, sizeof(sht)) != sizeof(sht)) { \n" \
"        perror(\"Error writing sht to file\\n\"); \n" \
"        return 1; \n" \
"    } \n" \
"    printf(\"binary file \\\"%s\\\" successfull created.\"); \n" \
"    close(fd); \n" \
"    return 0; \n" \
"} \n"

#define PRINT_C(format...) fprintf(fd, format)
#define PRINT_FILEADDR PRINT_C("/* %06x */", file_addr);
#define PRINT_CHAR(str, size, desc) do { PRINT_FILEADDR \
 PRINT_C("\t\"");                                         \
 for (_i_ = 0; _i_ < size; ++_i_) { \
   PRINT_C("\\x%x", str[_i_]); } \
 PRINT_C("\",\n"); file_addr += size; } while(0)

#define PRINT_WORD(value, desc) do { PRINT_FILEADDR PRINT_C("\t%d,\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_WORD_END(value, desc) do { PRINT_FILEADDR PRINT_C("\t%d\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_HALF(value, desc) PRINT_WORD(value, desc)
#define PRINT_ADDR(value, desc) do { PRINT_FILEADDR PRINT_C("\t0x%x,\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_ADDR_END(value, desc) do { PRINT_FILEADDR PRINT_C("\t0x%x\t/* %s */\n", value, desc); file_addr += sizeof(value); } while(0)
#define PRINT_OFF(value, desc) PRINT_ADDR(value, desc)
#define PADCHAR 0


_u8 reverse_elf2c(malelf_object* elf, FILE* fd) {
  ElfW(Ehdr)* header;
  ElfW(Phdr)* pheader;
  ElfW(Shdr)* sections;
  unsigned int file_addr = 0, _i_, i, j;
  /*  unsigned int segment_length = 0;*/
  _u8 count_str = 0;

  header = (ElfW(Ehdr)*) elf->mem;
  pheader = (ElfW(Phdr)*) (elf->mem + header->e_phoff);
  sections = (ElfW(Shdr)*) (elf->mem + header->e_shoff);

  PRINT_C(TOP_TEMPLATE);

  PRINT_C("Elf32_Ehdr elf_header = {\n");
  PRINT_CHAR(header->e_ident, EI_NIDENT, "Magic numbers");
  PRINT_HALF(header->e_type, GET_ATTR_DESC(get_header_type(header->e_type)));
  PRINT_HALF(header->e_machine, GET_ATTR_NAME(get_machine(header->e_machine)));
  PRINT_WORD(header->e_version, "CURRENT VERSION");
  PRINT_ADDR(header->e_entry, "Entry point");
  PRINT_OFF(header->e_phoff, "Program Header Table file offset");
  PRINT_OFF(header->e_shoff, "Section Header Table file offset");
  PRINT_WORD(header->e_flags, "Processor Spacefic-Flags");
  PRINT_HALF(header->e_ehsize, "ELF Header size in bytes");
  PRINT_HALF(header->e_phentsize, "Program Header Table entry size");
  PRINT_HALF(header->e_phnum, "Program Header Table entry count");
  PRINT_HALF(header->e_shentsize, "Section Header Table entry size");
  PRINT_HALF(header->e_shnum, "Section Header Table entry size");
  PRINT_WORD_END(header->e_shstrndx, "Section Header string table index");
  PRINT_C("};\n\n");
  
  PRINT_C("Elf32_Phdr pht[%d] = {\n", header->e_phnum);
  for (i = 0; i < header->e_phnum; i++) {
    PRINT_C("{\n");
    ElfW(Phdr)* p = (ElfW(Phdr)*) (pheader + i);
    PRINT_OFF(p->p_type, GET_ATTR_NAME(get_segment_type(p->p_type)));
    PRINT_OFF(p->p_offset, "Segment file offset ");
    PRINT_ADDR(p->p_vaddr, "Segment virtual address");
    PRINT_ADDR(p->p_paddr, "Segment physical address ");
    PRINT_WORD(p->p_filesz, "Segment size in file");
    PRINT_WORD(p->p_memsz, "Segment size in memory");
    PRINT_WORD(p->p_flags, "Segment flags");
    PRINT_WORD(p->p_align, "Segment alignment");
    PRINT_C("}");
    if (i < (unsigned)(header->e_phnum - 1)) {
      PRINT_C(",");
    } else {
      PRINT_C("};");
    }
    
    PRINT_C("\n");
  }

  PRINT_C("\n");

  /* Dumping sections */

  PRINT_C("const unsigned char segments[] = \n");

  for (i = 0; i < header->e_shnum; i++) {
    ElfW(Shdr)* s = (ElfW(Shdr)*) (sections + i);
    unsigned char* buf = (unsigned char*) (elf->mem + s->sh_offset);
    
    /* Jump SHT_NULL */
    if (s->sh_type == 0x00 || s->sh_type == SHT_NOBITS) {
      continue;
    }

    LOG_SUCCESS("%s:\t\t\taddress=%d\tstart=%d\tend=%d\tsize=%d\n", GET_SECTION_NAME(elf, header, sections, i), file_addr, s->sh_offset, s->sh_offset+s->sh_size, s->sh_size);

    if (file_addr < s->sh_offset) {
      PRINT_C("\n/* padding %d bytes */\n", s->sh_offset - file_addr);
      LOG_SUCCESS("%s: padding %d bytes\n", GET_SECTION_NAME(elf, header, sections, i), s->sh_offset - file_addr);
      
      for (; file_addr < s->sh_offset; file_addr++) {
        if (count_str == 0) {
          PRINT_C("/* %x */\t\"", file_addr);
        }

        PRINT_C("\\x00");

        if (count_str == 15) {
          PRINT_C("\"\n");
          count_str = 0;
        } else {
          count_str += 1;
        }
      }

      if (count_str > 0) {
        PRINT_C("\"\n\n");
      }
    }

    count_str = 0;

    PRINT_C("/* Dump of section: %s, offset=%d */\n", GET_SECTION_NAME(elf, header, sections, i), s->sh_offset);

    for (j = 0; j < s->sh_size; j++) {
      if (count_str == 0) {
        PRINT_C("/* %x */\t\"", file_addr);
      }

      PRINT_C("\\x%02x", *buf);
      file_addr += sizeof(*buf);
      
      if (count_str == 15) {
        PRINT_C("\"/* exit 1 */\n");
        count_str = 0;
      } else {
        count_str += 1;
      }

      buf = buf + 1;
    }

    if (count_str > 0) {
      PRINT_C("\"/* exit 2*/\n");
    }
  }

  count_str = 0;

  if (file_addr < header->e_shoff) {
    PRINT_C("\n/* padding %d bytes */\n", header->e_shoff - file_addr);
      
    for (; file_addr < header->e_shoff; file_addr++) {
      if (count_str == 0) {
        PRINT_C("/* %x */\t\"", file_addr);
      }

      PRINT_C("\\x00");

      if (count_str == 15) {
        PRINT_C("\"\n");
        count_str = 0;
      } else {
        count_str += 1;
      }
    }

    if (count_str > 0) {
      PRINT_C("\"\n\n");
    }
  }

  PRINT_C(";\n\n");

  PRINT_C("Elf32_Shdr sht[%d] = {\n", header->e_shnum);
  for (i = 0; i < header->e_shnum; i++) {
    ElfW(Shdr)* s = (ElfW(Shdr)*) (sections + i);
    PRINT_C("{\n");
    PRINT_C("/* Section: %s */\n", (char*) elf->mem + sections[header->e_shstrndx].sh_offset + sections[i].sh_name);
            
    PRINT_WORD(s->sh_name, "Section name (string tbl index)");
    PRINT_OFF(s->sh_type, GET_ATTR_NAME(get_section_type(s->sh_type)));
    PRINT_OFF(s->sh_flags, "Section flags");
    PRINT_ADDR(s->sh_addr, "Section virtual addr at execution");
    PRINT_OFF(s->sh_offset, "Section file offset");
    PRINT_WORD(s->sh_size, "Section size in bytes");
    PRINT_WORD(s->sh_link, "Link to another section");
    PRINT_WORD(s->sh_info, "Additional section information");
    PRINT_WORD(s->sh_addralign, "Section alignment ");
    PRINT_WORD(s->sh_entsize, "Entry size if section holds table");
    PRINT_C("}");
    if (i != (unsigned)(header->e_shnum - 1)) {
      PRINT_C(",");
    } else {
      PRINT_C("};\n");
    }
    PRINT_C("\n");
  }

  char* bname = basename(tmpnam(NULL));

  assert(bname != NULL);

  PRINT_C("\n");
  PRINT_C(SELF_GENERATE_SRC, bname, bname);


  return 0; 
}

void reverse_elf2cgen(int fd_input, int fd_output) {
  _u8* file_mem = NULL;
  struct stat st_info;    /* stat information */
  char* bname = basename(tmpnam(NULL));
  
  assert(fd_input != -1);
  assert(fd_output != -1);
  assert(bname != NULL);
  fstat(fd_input, &st_info);

  file_mem = mmap(0, st_info.st_size, PROT_READ, MAP_SHARED, fd_input, 0);
	
  if (file_mem == MAP_FAILED) {
    LOG_ERROR("mmap failed!\n");
    exit(1);
  }

  fprintf((FILE*)fd_output, "%s", (char*) file_mem);
  fprintf((FILE*)fd_output, SELF_GENERATE_SRC, bname, bname);
  
  if (file_mem) {
    munmap(file_mem, st_info.st_size);
  }
}
